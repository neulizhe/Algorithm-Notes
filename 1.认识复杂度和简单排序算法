1 常数操作
  和数据量无关。
  如：+ - * /;
      int a = arr[i];数组中找第i个元素    注：链表不行
         

2 选择排序——时间复杂度O(N²)，额外空间复杂度O(1)a
2.1 原理：
	episode 1，初始化一个inex。从0到N-1，找到最小值，用index记住最小值的下标。将arr[index]与arr[0]交换
	episode 2，从1到N-1，找到最小值，与arr[1]交换
	…………

2.2 代码：
void selectSort(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		int index = i;
		for (int j = i + 1; j < len; j++)
		{
			if (arr[j] < arr[index])
			{
				index = j;
			}
		}
		int temp = arr[i];
		arr[i] = arr[index];
		arr[index] = temp;
	}
}

2.3 补充：
	评价算法好坏，先看时间复杂度，O()相同时，再分析实际运行时间（也就是常数项时间，如 + - * / 与位运算 | & ^）


3.冒泡排序——时间复杂度O(N²)
3.1 原理：
	episode 1，从0~N-1，相邻交换，谁大谁右移，可以搞定arr[N-1]
	episode 2，从0~N-2，相邻交换，谁大谁右移，可以搞定arr[N-2]
	…………

3.2 代码：
void bubbleSort(int arr[], int len)
{
	for (int i = 1; i < len; i++)
	{
		for (int j = 0; j < len - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}


4.异或^
	0 0 - 0
	0 1 - 1
	1 0 - 1
	1 1 - 0		也可以看作是无进位相加

4.1 特点：
	具有交换律和结合律：a ^ b = b ^ a, a ^ b ^ c  = a ^ (b ^ c)
	0 ^ N = N, N ^ N = 0
	
4.2 异或实现swap（前提：a、b指向的内存是两块东西→arr[]时，i≠j）
int a = 甲;
int b = 乙;
a = a ^ b;	//a = 甲 ^ 乙, b = 乙
b = a ^ b;	//a = 甲 ^ 乙, b = 甲 ^ (乙 ^ 乙) = 甲
a = a ^ b;	//a = 甲 ^ 乙 ^ 甲 = 乙, b = 甲

4.3 面试题：
4.3.1 描述：
	有一个int arr[]，只有一种数出现了奇数次，其他的全出现了偶数次，1）怎么找到奇数次的？2）如果两种出现了奇数次，其他偶数次，如何找到这两个？

4.3.2 解：
1）初始化eor为0，对每个元素依次异或，偶数次的结果全为0，只剩下一个出现奇数次的数的值
	int eor = 0;
	for (int i = 0; i < len; i++)
	{
		eor = eor ^ arr[i];
	}
	
2）
？？？
？？？
？？？

5.插入排序
5.1 原理：
	想象为打斗地主抓牌的时候，从0~N，第N位开始看，比左小换，一直比下去，直到不换为止
	0~0不用换
	episode 1，0~1，看arr[1]，比左小就换，不小就停
	episode 2，0~2，看arr[2]，比左小就换，不小就停
	第几轮就看第几个数
	…………

5.2 代码：



6.二分法


7.对数器


8.递归求最大值


